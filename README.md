# Lab5 cow(copy on write)
 
lab5是实现cow(写时复制)这个特性，因为传统fork会复制父进程所有的用户空间到子进程中，如果父进程过大，那么复制就会花费很多时间。

更糟糕的是，子进程可能根本用不到这些空间，例如紧跟着执行exec，就会浪费大量的时间

下面是实现思路和细节

实现思路：

* fork的时候会创建一个页表给子进程，在创建该页表的时候，传统fork会让页表中pte都指向新的物理页，cow则是让子进程的页表pte都指向和父进程相同的物理页，同时，修改pte为只可读，不可写

* 当子进程准备写页表的时候，会发生page fault，在pagefalut的处理程序中，为子进程的pte指向的页分配一个新的物理页以及标记该pte为可写，然后重启写操作

* 值得注意的是物理页的释放问题，因为是父子进程共享物理页，所以可能存在一个物理页被多个进程的页表所引用，在释放的时候，应当等它的引用为0时，才能释放掉

实现细节：

* 修改uvmcopy函数 (`kernel/vm.c`) 让fork的时候不要分配物理页，而是共享物理页

* 修改usertrap函数 (`kernel/trap.c`) 判断trap类型根据寄存器`$scause`的值对page fault做出响应

* 在kmem结构体中 (`kernel/kalloc.c`) 添加一个数组，用来记录物理页的引用次数，下标为物理地址/页的大小

